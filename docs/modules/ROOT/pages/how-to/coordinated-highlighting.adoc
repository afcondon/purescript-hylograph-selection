= Coordinated Highlighting
:description: Synchronize visual emphasis across multiple views
:keywords: highlighting, hover, interaction, cross-view

Coordinated highlighting synchronizes visual emphasis across multiple views. When a user hovers over an element in one visualization, related elements in all views respond - some highlighted as primary, others as related, and unrelated elements dimmed.

== The Two-Tier Hover System

Hylograph provides two tiers of hover behavior:

=== Tier 1: Element-Local Hover (Simple)

For basic hover effects that only affect the element itself:

[source,purescript]
----
import Hylograph.Internal.Behavior.Types (onHover)

-- Simple style change on hover
T.elem Circle [...]
  `T.withBehaviors`
    [ onHover
        { enter: [{ attr: "stroke", value: "#333" }, { attr: "stroke-width", value: "3" }]
        , leave: [{ attr: "stroke", value: "#ddd" }, { attr: "stroke-width", value: "1.5" }]
        }
    ]
----

This is CSS-speed, element-local, and requires no coordination. Use it for simple feedback.

=== Tier 2: Coordinated Highlighting (Cross-View)

For synchronized highlighting across multiple visualizations:

[source,purescript]
----
import Hylograph.Internal.Behavior.Types (HighlightClass(..), onCoordinatedHighlight)
import Data.Maybe (Maybe(..))

T.elem Circle [...]
  `T.withBehaviors`
    [ onCoordinatedHighlight
        { identify: \d -> d.name           -- What does this element represent?
        , classify: \hoveredId d ->        -- How should it respond to hover?
            if d.name == hoveredId then Primary
            else if hoveredId `elem` d.connections then Related
            else Dimmed
        , group: Nothing                   -- Coordination scope (Nothing = global)
        , tooltip: Nothing                 -- Optional tooltip (see tooltip howto)
        }
    ]
----

== Core Concepts

=== Identity: What Does This Element Represent?

The `identify` function extracts a string identity from the element's datum:

[source,purescript]
----
identify: \d -> d.moduleName  -- A module node
identify: \d -> d.id          -- A generic entity
identify: \d -> show d.row <> "-" <> show d.col  -- A matrix cell
----

This identity is broadcast when the element is hovered.

=== Classification: How Should Elements Respond?

The `classify` function receives the hovered identity and the element's datum, returning a `HighlightClass`:

[source,purescript]
----
data HighlightClass
  = Primary   -- The hovered element itself (.highlight-primary)
  | Related   -- Connected/related elements (.highlight-related)
  | Dimmed    -- Unrelated elements (.highlight-dimmed)
  | Neutral   -- No change (default appearance)
----

Example classifications:

[source,purescript]
----
-- Simple same-name matching
classify: \hoveredId d ->
  if d.name == hoveredId then Primary else Dimmed

-- Relationship-aware (e.g., dependency graph)
classify: \hoveredId d ->
  if d.name == hoveredId then Primary
  else if hoveredId `elem` d.dependencies then Related
  else if d.name `elem` getReverseDeps hoveredId then Related
  else Dimmed

-- Matrix cell (row/column relationships)
classify: \hoveredId d ->
  if d.rowName == hoveredId && d.colName == hoveredId then Primary
  else if d.rowName == hoveredId || d.colName == hoveredId then Related
  else Dimmed
----

=== Groups: Scoping Coordination

By default, all elements with `group: Nothing` coordinate globally. Use named groups to isolate coordination:

[source,purescript]
----
-- These two views coordinate with each other
onCoordinatedHighlight { ..., group: Just "main-view" }

-- This view has independent highlighting
onCoordinatedHighlight { ..., group: Just "detail-panel" }
----

== CSS Classes

The library applies these CSS classes based on classification:

[source,css]
----
/* Primary - the hovered element and its equivalents */
.highlight-primary {
  opacity: 1 !important;
  stroke: #fbbf24 !important;
  stroke-width: 2px !important;
}

/* Related - connected elements */
.highlight-related {
  opacity: 0.85 !important;
  stroke: #60a5fa !important;
  stroke-width: 1.5px !important;
}

/* Dimmed - unrelated elements */
.highlight-dimmed {
  opacity: 0.2 !important;
}
----

Customize these in your CSS to match your visualization's aesthetic.

== Pattern: Enriched Datum Types

When using data joins with coordinated highlighting, create enriched datum types that carry everything needed for both rendering AND classification:

[source,purescript]
----
-- Enriched type with pre-computed relationships
type NodeDatum =
  { id :: String
  , name :: String
  , x :: Number
  , y :: Number
  , dependencies :: Array String    -- For classification
  , dependents :: Array String      -- For classification
  , cluster :: Int                  -- For coloring
  }

-- Build enriched data before the join
let enrichedNodes = nodes <#> \n ->
  { id: n.id
  , name: n.name
  , x: n.x
  , y: n.y
  , dependencies: getDeps n.id graph
  , dependents: getReverseDeps n.id graph
  , cluster: n.cluster
  }

-- Use in data join with template
T.joinData "nodes" "g" enrichedNodes $ \node ->
  T.elem Group [...]
    `T.withBehaviors`
      [ onCoordinatedHighlight
          { identify: _.name
          , classify: \hoveredId d ->
              if d.name == hoveredId then Primary
              else if hoveredId `elem` d.dependencies then Related
              else if hoveredId `elem` d.dependents then Related
              else Dimmed
          , group: Nothing
          , tooltip: Nothing
          }
      ]
----

== Multiple Element Types

Different element types can participate in the same coordination with different classification logic:

[source,purescript]
----
-- Nodes: Primary if same name
nodeHighlight = onCoordinatedHighlight
  { identify: _.name
  , classify: \hoveredId d ->
      if d.name == hoveredId then Primary else Dimmed
  , group: Nothing
  , tooltip: Nothing
  }

-- Links: Related if either endpoint matches
linkHighlight = onCoordinatedHighlight
  { identify: \l -> l.source.name  -- Links identify by source
  , classify: \hoveredId l ->
      if l.source.name == hoveredId || l.target.name == hoveredId
        then Related
        else Dimmed
  , group: Nothing
  , tooltip: Nothing
  }

-- Labels: Primary if same name
labelHighlight = onCoordinatedHighlight
  { identify: _.name
  , classify: \hoveredId d ->
      if d.name == hoveredId then Primary else Dimmed
  , group: Nothing
  , tooltip: Nothing
  }
----

== Pattern: Bidirectional Node-Edge Highlighting

In graph visualizations, you often want hovering to work both ways:

- Hover NODE → highlight connected edges
- Hover EDGE → highlight connected nodes

The key is using identity formats that encode relationship information:

[source,purescript]
----
import Data.String as String
import Data.String.Pattern (Pattern(..))

-- Edges use "source->target" as identity
edgeHighlight = onCoordinatedHighlight
  { identify: \e -> e.sourceName <> "->" <> e.targetName
  , classify: \hoveredId e ->
      let myId = e.sourceName <> "->" <> e.targetName
      in
        -- I am the hovered edge
        if hoveredId == myId then Primary
        -- A node is hovered, check if I'm connected
        else if hoveredId == e.sourceName || hoveredId == e.targetName then Related
        -- Otherwise dim
        else Dimmed
  , group: Nothing
  , tooltip: Nothing
  }

-- Nodes check if hovered identity is an edge connecting to them
nodeHighlight = onCoordinatedHighlight
  { identify: _.name
  , classify: \hoveredId n ->
      -- I am the hovered node
      if hoveredId == n.name then Primary
      -- An edge is hovered (contains "->"), check if I'm connected
      else if String.contains (Pattern "->") hoveredId then
        if String.contains (Pattern n.name) hoveredId
          then Related
          else Neutral
      -- Another node is hovered, stay neutral
      else Neutral
  , group: Nothing
  , tooltip: Nothing
  }
----

This pattern enables intuitive exploration: hover a node to see its connections, or hover an edge to see which nodes it connects.

== Important: Use Datum-Based Functions

When using `T.joinData` with nested elements, always use the datum parameter in `identify` and `classify` functions rather than closures:

[source,purescript]
----
-- WRONG: Closure captures stale values
T.joinData "edges" "g" edges $ \edge ->
  let sourceName = edge.source.name  -- Captured in closure
  in T.elem Group [...]
       `T.withBehaviors`
         [ onCoordinatedHighlight
             { identify: \_ -> sourceName  -- Ignores datum!
             , classify: \hoveredId _ -> ... sourceName ...  -- Ignores datum!
             ...
             }
         ]

-- RIGHT: Use datum parameter
T.joinData "edges" "g" edges $ \edge ->
  T.elem Group [...]
    `T.withBehaviors`
      [ onCoordinatedHighlight
          { identify: \d -> d.source.name  -- Uses datum
          , classify: \hoveredId d -> ... d.source.name ...  -- Uses datum
          ...
          }
      ]
----

The datum parameter ensures the functions work correctly regardless of element nesting.

== Important: Datum Timing

The library reads `__data__` fresh at event time, not at registration time. This means you can attach behaviors before D3 binds data to elements - a common pattern with the Tree API's `T.withBehaviors`.

== Cleanup

When re-rendering visualizations, call `clearAllHighlights_` to reset state:

[source,purescript]
----
import Hylograph.Internal.Behavior.FFI (clearAllHighlights_)

-- Before re-rendering
liftEffect clearAllHighlights_
----

This removes all highlight classes and clears the element registry.
