= Hylograph in a React Application
:description: How to integrate Hylograph visualizations into purescript-react-basic-hooks applications
:keywords: React, react-basic-hooks, integration, framework-agnostic

Hylograph is framework-agnostic: the same visualization code works whether you're using React, Halogen, or vanilla JavaScript. This guide shows how to integrate Hylograph with `purescript-react-basic-hooks`.

== The Key Insight

Hylograph doesn't care about your UI framework. It just needs:

1. A DOM element to render into
2. A trigger to render (mount, prop change, etc.)

The framework provides the container and lifecycle; Hylograph handles the visualization.

== The Pattern

[source,purescript]
----
mkMyVisualization :: Component { data :: Array Number }
mkMyVisualization = do
  -- 1. Generate unique container ID (once per component instance)
  containerId <- useContainerId

  component "MyVisualization" \props -> React.do
    -- 2. Render visualization when component mounts
    useEffectOnce do
      let selector = "#" <> containerId
      void $ rerender selector (myVisualizationTree props.data)
      pure mempty

    -- 3. Return container div with our unique ID
    pure $ R.div
      { id: containerId
      , style: R.css { width: "500px", height: "300px" }
      }
----

== Container ID Helper

Each component instance needs a unique container ID to avoid conflicts when multiple visualizations are on the same page.

.src/Hylograph/React/Hooks.purs
[source,purescript]
----
module Hylograph.React.Hooks (useContainerId) where

import Effect (Effect)

foreign import generateContainerIdImpl :: Effect String

useContainerId :: Effect String
useContainerId = generateContainerIdImpl
----

.src/Hylograph/React/Hooks.js
[source,javascript]
----
let counter = 0;

export const generateContainerIdImpl = () => `hylograph-container-${counter++}`;
----

== Complete Bar Chart Example

Here's a complete example showing a data-bound bar chart:

[source,purescript]
----
module Hylograph.React.Example where

import Prelude

import Data.Array as Array
import Data.Int (toNumber)
import Effect (Effect)
import Hylograph.HATS as H
import Hylograph.HATS.Friendly as HF
import Hylograph.Expr.Friendly (num, text, width, height, x, y, fill)
import Hylograph.HATS.InterpreterTick (rerender)
import Hylograph.React.Hooks (useContainerId)
import React.Basic.DOM as R
import React.Basic.Hooks (Component, component, useEffectOnce)
import React.Basic.Hooks as React

-- | Bar chart component with data binding
mkBarChart :: Component { chartData :: Array Number }
mkBarChart = do
  containerId <- useContainerId

  component "BarChart" \props -> React.do
    useEffectOnce do
      let selector = "#" <> containerId
      void $ rerender selector (barChartTree props.chartData)
      pure mempty

    pure $ R.div
      { id: containerId
      , style: R.css { width: "500px", height: "300px" }
      }

-- | The visualization tree - identical to what you'd write for Halogen
barChartTree :: Array Number -> H.Tree
barChartTree dataset =
  HF.svg [ width $ num 500.0, height $ num 300.0, style $ text "background: #f5f5f5" ]
    (dataset # Array.mapWithIndex \i val ->
      HF.rect
        [ x $ num (toNumber i * 60.0 + 20.0)
        , y $ num (280.0 - val * 2.5)
        , width $ num 50.0
        , height $ num (val * 2.5)
        , fill $ text (barColor val)
        ])

barColor :: Number -> String
barColor val
  | val > 75.0 = "steelblue"
  | val > 50.0 = "cornflowerblue"
  | otherwise = "lightsteelblue"
----

== Using DOM Elements Directly

If you prefer using React refs instead of CSS selectors, Hylograph provides `selectElement`:

[source,purescript]
----
import Hylograph.Render (runD3, selectElement)
import Hylograph.Render (renderData)
import React.Basic.Hooks (useRef)
import Web.HTML.HTMLElement (toElement)
import Data.Nullable (toMaybe)

mkChartWithRef :: Component { data :: Array Number }
mkChartWithRef = do
  component "ChartWithRef" \props -> React.do
    containerRef <- useRef null

    useEffectOnce do
      for_ (toMaybe =<< toMaybe containerRef.current) \htmlEl -> do
        let element = toElement htmlEl
        void $ rerenderInto element (myChartTree props.data)
      pure mempty

    pure $ R.div { ref: containerRef }
----

== Responding to Prop Changes

To re-render when props change, use `useEffect` with a dependency:

[source,purescript]
----
mkDynamicChart :: Component { chartData :: Array Number }
mkDynamicChart = do
  containerId <- useContainerId

  component "DynamicChart" \props -> React.do
    -- Re-render when chartData changes
    useEffect props.chartData do
      let selector = "#" <> containerId
      void $ rerender selector (barChartTree props.chartData)
      pure mempty

    pure $ R.div { id: containerId }
----

== Project Setup

Add these dependencies to your `spago.yaml`:

[source,yaml]
----
package:
  dependencies:
    - hylograph-selection
    - react-basic
    - react-basic-dom
    - react-basic-hooks
----

If using local Hylograph packages:

[source,yaml]
----
workspace:
  extraPackages:
    hylograph-selection:
      path: ../purescript-hylograph-selection
    hylograph-graph:
      path: ../purescript-hylograph-graph
----

== Why Framework-Agnostic Matters

The visualization code (`barChartTree`) is completely decoupled from React. This means:

* **Reusable**: The same tree works in Halogen, React, or vanilla JS
* **Testable**: Test visualization logic without a framework
* **Portable**: Switch frameworks without rewriting visualizations

== Next Steps

* xref:how-to/react-events.adoc[React Events from Hylograph] - Click handlers and state updates
* xref:how-to/react-simulation.adoc[Force Simulations in React] - Tick callbacks and drag
* xref:how-to/halogen-events.adoc[Halogen Events from Hylograph] - Compare with Halogen
* xref:how-to/simple-webpage.adoc[Hylograph in a Simple Web Page] - No framework at all
